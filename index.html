<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pokémon TCG Decklist</title>
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.25.6/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @media print {
            .no-print { display: none; }
            body { margin: 0; }
            #decklist-container { box-shadow: none; border: none; }
            @page { margin: 0in; size: A4; }
            .side-by-side { display: block; }
        }
        .dropdown {
            position: relative;
            width: 100%;
        }
        .dropdown-list {
            display: none;
            position: absolute;
            width: 100%;
            max-height: 150px;
            overflow-y: auto;
            background-color: white;
            border: 1px solid #ccc;
            z-index: 10;
        }
        .dropdown-list.active {
            display: block;
        }
        .dropdown-option {
            padding: 2px 5px;
            cursor: pointer;
        }
        .dropdown-option:hover {
            background-color: #f0f0f0;
        }
    </style>
</head>
<body class="bg-gray-200 flex justify-center min-h-screen p-2">
    <div id="root" className="w-full max-w-3xl"></div>
    <script type="text/babel">
        const CustomDropdown = ({ options, value, onChange, section, index }) => {
            const [isOpen, setIsOpen] = React.useState(false);
            const [inputValue, setInputValue] = React.useState(value);
            const inputRef = React.useRef(null);

            const handleToggle = () => {
                setIsOpen(true);
                if (inputRef.current) {
                    inputRef.current.select();
                }
            };

            const handleSelect = (option) => {
                setInputValue(option);
                onChange(section, index, "name", option);
                setIsOpen(false);
            };

            const handleInputChange = (e) => {
                setInputValue(e.target.value);
                if (!isOpen) setIsOpen(true);
            };

            const filteredOptions = options.filter(([name]) =>
                name.toLowerCase().startsWith(inputValue.toLowerCase())
            );

            return (
                <div className="dropdown">
                    <input
                        ref={inputRef}
                        type="text"
                        value={inputValue}
                        onChange={handleInputChange}
                        onFocus={handleToggle}
                        onBlur={() => setTimeout(() => setIsOpen(false), 200)}
                        className="w-full p-[1.7px] border border-black rounded text-[12px]"
                        placeholder={`Search ${section.charAt(0).toUpperCase() + section.slice(1)}`}
                    />
                    <div className={`dropdown-list ${isOpen ? 'active' : ''}`}>
                        {filteredOptions.map(([name]) => (
                            <div
                                key={name}
                                className="dropdown-option"
                                onClick={() => handleSelect(name)}
                            >
                                {name}
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const DecklistForm = () => {
            const [playerInfo, setPlayerInfo] = React.useState({
                name: "",
                id: "",
                dob: "",
                division: ""
            });
            const [cards, setCards] = React.useState({
                pokemon: [{ id: Date.now(), name: "", coll: "", set: "", reg: "", qty: 0 }],
                trainer: [{ id: Date.now() + 1, name: "", qty: 0 }],
                energy: [{ id: Date.now() + 2, name: "", qty: 0 }]
            });
            const [cardData, setCardData] = React.useState({
                pokemon: [[" "]],
                pokemonCollSetReg: {},
                trainer: [[" "]],
                energy: [[" "]]
            });
            const [isLoading, setIsLoading] = React.useState(true);
            const [error, setError] = React.useState(null);
            const [showImportModal, setShowImportModal] = React.useState(false);
            const [importText, setImportText] = React.useState("");
            const fileInputRef = React.useRef(null);

            const energyMap = {
                "Basic {D} Energy": "Darkness Energy",
                "Basic {R} Energy": "Fire Energy",
                "Basic {G} Energy": "Grass Energy",
                "Basic {W} Energy": "Water Energy",
                "Basic {L} Energy": "Lightning Energy",
                "Basic {P} Energy": "Psychic Energy",
                "Basic {F} Energy": "Fighting Energy",
                "Basic {M} Energy": "Metal Energy"
            };

            const generateId = () => Date.now() + Math.random();

            React.useEffect(() => {
                setIsLoading(true);
                fetch("./data/cards.json")
                    .then((response) => {
                        if (!response.ok) throw new Error("Failed to fetch card data");
                        return response.json();
                    })
                    .then((data) => {
                        if (!data.pokemon || !data.pokemonCollSetReg || !data.trainer || !data.energy) {
                            throw new Error("Invalid card data format");
                        }
                        setCardData(data);
                        setIsLoading(false);
                        setError(null);
                    })
                    .catch((error) => {
                        console.error("Error fetching card data:", error);
                        setError("Failed to load card data. Please ensure cards.json is accessible and try again.");
                        setIsLoading(false);
                        setCardData({
                            pokemon: [[" "]],
                            pokemonCollSetReg: {},
                            trainer: [[" "]],
                            energy: [[" "]]
                        });
                    });
            }, []);

            const calculateDivision = (dob) => {
                if (!dob) return "";
                const birthYear = new Date(dob).getFullYear();
                const currentYear = new Date().getFullYear();
                if (birthYear >= currentYear - 12) return "Junior";
                if (birthYear >= currentYear - 16 && birthYear <= currentYear - 13) return "Senior";
                return "Masters";
            };

            const handlePlayerInfoChange = (field, value) => {
                const updatedInfo = { ...playerInfo, [field]: value };
                if (field === "dob") {
                    updatedInfo.division = calculateDivision(value);
                }
                setPlayerInfo(updatedInfo);
            };

            const handleCardChange = (section, id, field, value) => {
                const updatedCards = { ...cards };
                const rowIndex = updatedCards[section].findIndex(card => card.id === id);
                if (rowIndex === -1) return;
                updatedCards[section][rowIndex] = { ...updatedCards[section][rowIndex], [field]: value };

                if (section === "pokemon" && field === "name") {
                    updatedCards[section][rowIndex].coll = "";
                    updatedCards[section][rowIndex].set = "";
                    updatedCards[section][rowIndex].reg = "";
                }
                if (section === "pokemon" && field === "coll") {
                    const [set, reg] = getSetAndRegulation(updatedCards[section][rowIndex].name, value);
                    updatedCards[section][rowIndex].set = set;
                    updatedCards[section][rowIndex].reg = reg;
                }

                setCards(updatedCards);
            };

            const getCollNumbers = (pokemonName) => {
                return cardData.pokemonCollSetReg[pokemonName]?.map(([coll]) => coll) || [""];
            };

            const getSetAndRegulation = (pokemonName, coll) => {
                const entry = cardData.pokemonCollSetReg[pokemonName]?.find(([c]) => c === coll);
                if (entry) {
                    const [, setReg] = entry;
                    const [set, reg] = setReg.split(",");
                    return [set, reg];
                }
                return ["", ""];
            };

            const addRow = (section) => {
                const updatedCards = { ...cards };
                if (updatedCards[section].length >= 50) return;
                const newRow = section === "pokemon"
                    ? { id: generateId(), name: "", coll: "", set: "", reg: "", qty: 0 }
                    : { id: generateId(), name: "", qty: 0 };
                updatedCards[section] = [...updatedCards[section], newRow];
                setCards(updatedCards);
            };

            const removeRow = (section, id) => {
                const updatedCards = { ...cards };
                if (updatedCards[section].length <= 1) return;
                updatedCards[section] = updatedCards[section].filter(card => card.id !== id);
                setCards(updatedCards);
            };

            const handleExport = () => {
                const fileName = window.prompt("Enter file name for export", "decklist.txt");
                if (!fileName) return; // Do nothing if canceled
                const sanitizedFileName = fileName.endsWith(".txt") ? fileName : `${fileName}.txt`;
                const pokemonText = cards.pokemon
                    .filter(card => card.qty > 0 && card.name)
                    .map(card => `${card.qty}, ${card.name}, ${card.coll}, ${card.set}, ${card.reg}`)
                    .join("\n");
                const trainerText = cards.trainer
                    .filter(card => card.qty > 0 && card.name)
                    .map(card => `${card.qty}, ${card.name}`)
                    .join("\n");
                const energyText = cards.energy
                    .filter(card => card.qty > 0 && card.name)
                    .map(card => `${card.qty}, ${card.name}`)
                    .join("\n");
                const total = Object.values(cards).flat().reduce((sum, card) => sum + (Number(card.qty) || 0), 0);
                const content = `Pokémon:\n${pokemonText}\nTrainer:\n${trainerText}\nEnergy:\n${energyText}\nTotal Cards: ${total}`;
                const blob = new Blob([content], { type: "text/plain" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = sanitizedFileName;
                a.click();
                URL.revokeObjectURL(url);
            };

            const parsePTCGLText = (text) => {
                const lines = text.split("\n").map(line => line.trim());
                let currentSection = null;
                const pokemon = [];
                const trainer = [];
                const energy = [];
                const invalidSets = [];

                for (const line of lines) {
                    if (line.startsWith("Pokémon:")) {
                        currentSection = "pokemon";
                        continue;
                    } else if (line.startsWith("Trainer:")) {
                        currentSection = "trainer";
                        continue;
                    } else if (line.startsWith("Energy:")) {
                        currentSection = "energy";
                        continue;
                    } else if (line.startsWith("Total Cards:") || !line) {
                        continue;
                    }

                    const tokens = line.split(" ");
                    if (tokens.length < 2) {
                        console.warn(`Skipping malformed line: ${line}`);
                        continue;
                    }
                    const qtyMatch = tokens[0].match(/^\d+$/);
                    if (!qtyMatch) {
                        console.warn(`Invalid quantity in line: ${line}`);
                        continue;
                    }
                    const qty = parseInt(qtyMatch[0]);
                    let coll = "";
                    let set = "";
                    let nameIndex = 1;
                    for (let i = tokens.length - 1; i >= 1; i--) {
                        if (tokens[i].match(/^\d+$/)) {
                            coll = tokens[i];
                            set = tokens[i - 1];
                            nameIndex = i - 1;
                            break;
                        }
                    }
                    const name = tokens.slice(1, nameIndex).join(" ");
                    if (!name) {
                        console.warn(`Empty name in line: ${line}`);
                        continue;
                    }

                    if (currentSection === "pokemon") {
                        pokemon.push({ qty, name, coll, set });
                    } else if (currentSection === "trainer" || currentSection === "energy") {
                        const mappedName = currentSection === "energy" ? (energyMap[name] || name) : name;
                        if (!cardData[currentSection].some(([item]) => item === mappedName)) {
                            console.warn(`Invalid ${currentSection} name: ${mappedName}`);
                            continue;
                        }
                        (currentSection === "trainer" ? trainer : energy).push({ qty, name: mappedName });
                    }
                }

                // Process Pokémon: Merge valid and invalid sets
                const pokemonMap = {};
                for (const card of pokemon) {
                    if (!pokemonMap[card.name]) {
                        pokemonMap[card.name] = { valid: [], invalid: [] };
                    }
                    const entry = cardData.pokemonCollSetReg[card.name]?.find(([c]) => c === card.coll);
                    if (entry && cardData.pokemon.some(([p]) => p === card.name)) {
                        pokemonMap[card.name].valid.push(card);
                    } else {
                        pokemonMap[card.name].invalid.push(card);
                        invalidSets.push(`${card.qty} ${card.name} ${card.set} ${card.coll}`);
                    }
                }
                const parsedPokemon = [];
                for (const name in pokemonMap) {
                    const { valid, invalid } = pokemonMap[name];
                    const validMap = {};
                    for (const card of valid) {
                        const key = `${card.set}-${card.coll}`;
                        if (!validMap[key]) {
                            validMap[key] = { qty: 0, coll: card.coll, set: card.set };
                        }
                        validMap[key].qty += card.qty;
                    }
                    for (const key in validMap) {
                        const { qty, coll, set } = validMap[key];
                        const [setVal, reg] = getSetAndRegulation(name, coll);
                        parsedPokemon.push({ id: generateId(), qty: Math.min(qty, 4), name, coll, set: setVal, reg });
                    }
                    const invalidQty = invalid.reduce((sum, card) => sum + card.qty, 0);
                    if (invalidQty > 0) {
                        parsedPokemon.push({ id: generateId(), qty: Math.min(invalidQty, 4), name, coll: "", set: "", reg: "" });
                    }
                }

                // Process Trainer: Combine duplicates
                const trainerMap = {};
                for (const card of trainer) {
                    trainerMap[card.name] = (trainerMap[card.name] || 0) + card.qty;
                }
                const parsedTrainer = Object.entries(trainerMap).map(([name, qty]) => ({
                    id: generateId(),
                    qty: Math.min(qty, 4),
                    name
                }));

                // Process Energy: Combine duplicates
                const energyMapCounts = {};
                for (const card of energy) {
                    energyMapCounts[card.name] = (energyMapCounts[card.name] || 0) + card.qty;
                }
                const parsedEnergy = Object.entries(energyMapCounts).map(([name, qty]) => ({
                    id: generateId(),
                    qty: Math.min(qty, 60),
                    name
                }));

                return { pokemon: parsedPokemon, trainer: parsedTrainer, energy: parsedEnergy, invalidSets };
            };

            const handleImportFile = () => {
                if (fileInputRef.current) {
                    fileInputRef.current.click();
                }
            };

            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                if (!window.confirm("Replace current decklist?")) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    const text = e.target.result;
                    const lines = text.split("\n").map(line => line.trim());
                    let currentSection = null;
                    const pokemon = [];
                    const trainer = [];
                    const energy = [];
                    const invalidSets = [];

                    for (const line of lines) {
                        if (line.startsWith("Pokémon:")) {
                            currentSection = "pokemon";
                            continue;
                        } else if (line.startsWith("Trainer:")) {
                            currentSection = "trainer";
                            continue;
                        } else if (line.startsWith("Energy:")) {
                            currentSection = "energy";
                            continue;
                        } else if (line.startsWith("Total Cards:") || !line) {
                            continue;
                        }

                        if (currentSection === "pokemon") {
                            const [qty, name, coll, set, reg] = line.split(",").map(item => item.trim());
                            if (!name || isNaN(qty)) {
                                console.warn(`Invalid Pokémon line: ${line}`);
                                continue;
                            }
                            if (!cardData.pokemon.some(([p]) => p === name)) {
                                console.warn(`Invalid Pokémon name: ${name}`);
                                continue;
                            }
                            pokemon.push({ qty: parseInt(qty), name, coll, set, reg });
                        } else if (currentSection === "trainer" || currentSection === "energy") {
                            const [qty, name] = line.split(",").map(item => item.trim());
                            if (!name || isNaN(qty)) {
                                console.warn(`Invalid ${currentSection} line: ${line}`);
                                continue;
                            }
                            const mappedName = currentSection === "energy" ? (energyMap[name] || name) : name;
                            if (!cardData[currentSection].some(([item]) => item === mappedName)) {
                                console.warn(`Invalid ${currentSection} name: ${mappedName}`);
                                continue;
                            }
                            (currentSection === "trainer" ? trainer : energy).push({ qty: parseInt(qty), name: mappedName });
                        }
                    }

                    // Process Pokémon: Merge duplicates, validate sets
                    const pokemonMap = {};
                    for (const card of pokemon) {
                        if (!pokemonMap[card.name]) {
                            pokemonMap[card.name] = { valid: [], invalid: [] };
                        }
                        const entry = cardData.pokemonCollSetReg[card.name]?.find(([c]) => c === card.coll);
                        if (entry) {
                            pokemonMap[card.name].valid.push(card);
                        } else {
                            pokemonMap[card.name].invalid.push(card);
                            invalidSets.push(`${card.qty} ${card.name} ${card.set} ${card.coll}`);
                        }
                    }
                    const parsedPokemon = [];
                    for (const name in pokemonMap) {
                        const { valid, invalid } = pokemonMap[name];
                        const validMap = {};
                        for (const card of valid) {
                            const key = `${card.set}-${card.coll}`;
                            if (!validMap[key]) {
                                validMap[key] = { qty: 0, coll: card.coll, set: card.set, reg: card.reg };
                            }
                            validMap[key].qty += card.qty;
                        }
                        for (const key in validMap) {
                            const { qty, coll, set, reg } = validMap[key];
                            parsedPokemon.push({ id: generateId(), qty: Math.min(qty, 4), name, coll, set, reg });
                        }
                        const invalidQty = invalid.reduce((sum, card) => sum + card.qty, 0);
                        if (invalidQty > 0) {
                            parsedPokemon.push({ id: generateId(), qty: Math.min(invalidQty, 4), name, coll: "", set: "", reg: "" });
                        }
                    }

                    // Process Trainer: Combine duplicates
                    const trainerMap = {};
                    for (const card of trainer) {
                        trainerMap[card.name] = (trainerMap[card.name] || 0) + card.qty;
                    }
                    const parsedTrainer = Object.entries(trainerMap).map(([name, qty]) => ({
                        id: generateId(),
                        qty: Math.min(qty, 4),
                        name
                    }));

                    // Process Energy: Combine duplicates
                    const energyMapCounts = {};
                    for (const card of energy) {
                        energyMapCounts[card.name] = (energyMapCounts[card.name] || 0) + card.qty;
                    }
                    const parsedEnergy = Object.entries(energyMapCounts).map(([name, qty]) => ({
                        id: generateId(),
                        qty: Math.min(qty, 60),
                        name
                    }));

                    if (parsedPokemon.length === 0 && parsedTrainer.length === 0 && parsedEnergy.length === 0) {
                        alert("Invalid format: no valid cards found.");
                        return;
                    }

                    setCards({ pokemon: parsedPokemon, trainer: parsedTrainer, energy: parsedEnergy });
                    setShowImportModal(false);
                    setImportText("");
                    if (invalidSets.length > 0) {
                        window.alert(`Invalid sets detected for the following Pokémon:\n${invalidSets.join("\n")}`);
                    }
                };
                reader.readAsText(file);
            };

            const handleImportText = () => {
                if (!importText) {
                    alert("Please paste PTCGL text to import.");
                    return;
                }
                if (!window.confirm("Replace current decklist?")) return;
                const { pokemon, trainer, energy, invalidSets } = parsePTCGLText(importText);
                if (pokemon.length === 0 && trainer.length === 0 && energy.length === 0) {
                    alert("Invalid format: no valid cards found.");
                    return;
                }
                setCards({ pokemon, trainer, energy });
                setShowImportModal(false);
                setImportText("");
                if (invalidSets.length > 0) {
                    window.alert(`Invalid sets detected for the following Pokémon:\n${invalidSets.join("\n")}`);
                }
            };

            const totalCards = Object.values(cards).flat().reduce((sum, card) => sum + (Number(card.qty) || 0), 0);
            const pokemonCount = Number(cards.pokemon.reduce((sum, card) => sum + (card.qty || 0), 0));
            const trainerCount = Number(cards.trainer.reduce((sum, card) => sum + (card.qty || 0), 0));
            const energyCount = Number(cards.energy.reduce((sum, card) => sum + (card.qty || 0), 0));

            const resetForm = () => {
                setPlayerInfo({ name: "", id: "", dob: "", division: "" });
                setCards({
                    pokemon: [{ id: generateId(), name: "", coll: "", set: "", reg: "", qty: 0 }],
                    trainer: [{ id: generateId(), name: "", qty: 0 }],
                    energy: [{ id: generateId(), name: "", qty: 0 }]
                });
            };

            const handlePrint = () => {
                window.print();
            };

            return (
                <div id="decklist-container" className="bg-white p-[5.1px] rounded-lg shadow-lg font-sans">
                    {isLoading && <p className="text-[12px] text-center">Loading card data...</p>}
                    {error && <p className="text-red-600 text-[12px] text-center">{error}</p>}
                    {!isLoading && !error && (
                        <>
                            <div className="border-b-2 border-black mb-[6.8px] pb-[1.7px]">
                                <h1 className="text-[13.5px] font-bold text-center">Pokémon Trading Card Game Deck List</h1>
                            </div>
                            <div className="grid grid-cols-[2fr,1fr,2fr,1fr] gap-2 mb-[6.8px]">
                                <div>
                                    <label className="block text-[12px] font-bold">Player Name:</label>
                                    <input
                                        type="text"
                                        value={playerInfo.name}
                                        onChange={(e) => handlePlayerInfoChange("name", e.target.value)}
                                        className="w-full p-[1.7px] border border-black rounded text-[12px]"
                                        placeholder="Enter name"
                                    />
                                </div>
                                <div>
                                    <label className="block text-[12px] font-bold">Player ID:</label>
                                    <input
                                        type="text"
                                        value={playerInfo.id}
                                        onChange={(e) => handlePlayerInfoChange("id", e.target.value)}
                                        className="w-full p-[1.7px] border border-black rounded text-[12px]"
                                        placeholder="Enter ID"
                                    />
                                </div>
                                <div>
                                    <label className="block text-[12px] font-bold">Date of Birth:</label>
                                    <input
                                        type="date"
                                        value={playerInfo.dob}
                                        onChange={(e) => handlePlayerInfoChange("dob", e.target.value)}
                                        className="w-full p-[1.7px] border border-black rounded text-[12px]"
                                    />
                                </div>
                                <div>
                                    <label className="block text-[12px] font-bold">Division:</label>
                                    <input
                                        type="text"
                                        value={playerInfo.division}
                                        readOnly
                                        className="w-full p-[1.7px] border border-black rounded bg-gray-100 text-[12px]"
                                    />
                                </div>
                            </div>

                            <div className="mb-[6.8px]">
                                <h2 className="text-[10.5px] font-bold border-b border-black">Pokémon: {pokemonCount}</h2>
                                <div className="grid grid-cols-9 gap-1 text-[12px] font-bold border-b border-black py-[1.7px]">
                                    <span>Qty:</span>
                                    <span className="col-span-4">Name:</span>
                                    <span>Set:</span>
                                    <span className="col-span-1">Coll.#:</span>
                                    <span>Reg:</span>
                                    <span className="no-print"></span>
                                </div>
                                {cards.pokemon.map((card) => (
                                    <div key={card.id} className="grid grid-cols-9 gap-1 text-[12px] border-b border-gray-300 py-[1.7px]">
                                        <select
                                            value={card.qty}
                                            onChange={(e) => handleCardChange("pokemon", card.id, "qty", e.target.value)}
                                            className="p-[1.7px] border border-black rounded text-[12px]"
                                        >
                                            {[0, 1, 2, 3, 4].map((num) => (
                                                <option key={num} value={num}>{num}</option>
                                            ))}
                                        </select>
                                        <div className="col-span-4">
                                            <CustomDropdown
                                                options={cardData.pokemon}
                                                value={card.name}
                                                onChange={handleCardChange}
                                                section="pokemon"
                                                index={card.id}
                                            />
                                        </div>
                                        <input
                                            type="text"
                                            value={card.set}
                                            readOnly
                                            className="p-[1.7px] border border-black rounded bg-gray-100 text-[12px] text-left"
                                            style={{ paddingLeft: "2px" }}
                                            placeholder="Set"
                                        />
                                        <select
                                            value={card.coll}
                                            onChange={(e) => handleCardChange("pokemon", card.id, "coll", e.target.value)}
                                            className="col-span-1 p-[1.7px] border border-black rounded text-[12px]"
                                            disabled={!card.name || card.name === " "}
                                        >
                                            <option value="">-</option>
                                            {getCollNumbers(card.name).map((coll) => (
                                                <option key={coll} value={coll}>{coll}</option>
                                            ))}
                                        </select>
                                        <input
                                            type="text"
                                            value={card.reg}
                                            readOnly
                                            className="p-[1.7px] border border-black rounded bg-gray-100 text-[12px] text-left"
                                            style={{ paddingLeft: "2px" }}
                                            placeholder="Reg"
                                        />
                                        <button
                                            onClick={() => removeRow("pokemon", card.id)}
                                            className="no-print text-red-600 font-extrabold text-[10.5px]"
                                            disabled={cards.pokemon.length <= 1}
                                        >
                                            X
                                        </button>
                                    </div>
                                ))}
                                <div className="text-left mt-[3.4px] leading-[0.25]">
                                    <button
                                        onClick={() => addRow("pokemon")}
                                        className="no-print text-green-600 font-extrabold text-[15px]"
                                    >
                                        +
                                    </button>
                                </div>
                            </div>

                            <div className="side-by-side grid grid-cols-2 gap-4 mb-[6.8px]">
                                <div>
                                    <h2 className="text-[10.5px] font-bold border-b border-black">Trainer: {trainerCount}</h2>
                                    <div className="grid grid-cols-9 gap-1 text-[12px] font-bold border-b border-black py-[1.7px]">
                                        <span className="col-span-2">Qty:</span>
                                        <span className="col-span-6">Name:</span>
                                        <span className="no-print"></span>
                                    </div>
                                    {cards.trainer.map((card) => (
                                        <div key={card.id} className="grid grid-cols-9 gap-1 text-[12px] border-b border-gray-300 py-[1.7px]">
                                            <select
                                                value={card.qty}
                                                onChange={(e) => handleCardChange("trainer", card.id, "qty", e.target.value)}
                                                className="col-span-2 p-[1.7px] border border-black rounded text-[12px]"
                                            >
                                                {[0, 1, 2, 3, 4].map((num) => (
                                                    <option key={num} value={num}>{num}</option>
                                                ))}
                                            </select>
                                            <div className="col-span-6">
                                                <CustomDropdown
                                                    options={cardData.trainer}
                                                    value={card.name}
                                                    onChange={handleCardChange}
                                                    section="trainer"
                                                    index={card.id}
                                                />
                                            </div>
                                            <button
                                                onClick={() => removeRow("trainer", card.id)}
                                                className="no-print text-red-600 font-extrabold text-[10.5px]"
                                                disabled={cards.trainer.length <= 1}
                                            >
                                                X
                                            </button>
                                        </div>
                                    ))}
                                    <div className="text-left mt-[3.4px] leading-[0.25]">
                                        <button
                                            onClick={() => addRow("trainer")}
                                            className="no-print text-green-600 font-extrabold text-[15px]"
                                        >
                                            +
                                        </button>
                                    </div>
                                </div>

                                <div>
                                    <h2 className="text-[10.5px] font-bold border-b border-black">Energy: {energyCount}</h2>
                                    <div className="grid grid-cols-9 gap-1 text-[12px] font-bold border-b border-black py-[1.7px]">
                                        <span className="col-span-2">Qty:</span>
                                        <span className="col-span-6">Name:</span>
                                        <span className="no-print"></span>
                                    </div>
                                    {cards.energy.map((card) => (
                                        <div key={card.id} className="grid grid-cols-9 gap-1 text-[12px] border-b border-gray-300 py-[1.7px]">
                                            <select
                                                value={card.qty}
                                                onChange={(e) => handleCardChange("energy", card.id, "qty", e.target.value)}
                                                className="col-span-2 p-[1.7px] border border-black rounded text-[12px]"
                                            >
                                                {[...Array(60).keys()].map((num) => (
                                                    <option key={num} value={num}>{num}</option>
                                                ))}
                                            </select>
                                            <div className="col-span-6">
                                                <CustomDropdown
                                                    options={cardData.energy}
                                                    value={card.name}
                                                    onChange={handleCardChange}
                                                    section="energy"
                                                    index={card.id}
                                                />
                                            </div>
                                            <button
                                                onClick={() => removeRow("energy", card.id)}
                                                className="no-print text-red-600 font-extrabold text-[10.5px]"
                                                disabled={cards.energy.length <= 1}
                                            >
                                                X
                                            </button>
                                        </div>
                                    ))}
                                    <div className="text-left mt-[3.4px] leading-[0.15]">
                                        <button
                                            onClick={() => addRow("energy")}
                                            className="no-print text-green-600 font-extrabold text-[15px]"
                                        >
                                            +
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <div className="flex justify-between items-center mt-[6.8px]">
                                <div>
                                    <p className="text-[12px] font-bold">Total Cards: {totalCards}</p>
                                </div>
                                <div className="flex gap-2 no-print">
                                    <button
                                        onClick={resetForm}
                                        className="bg-red-600 text-white px-[1.7px] py-[1.7px] rounded hover:bg-red-700 text-[12px]"
                                    >
                                        Reset
                                    </button>
                                    <button
                                        onClick={() => setShowImportModal(true)}
                                        className="bg-blue-600 text-white px-[1.7px] py-[1.7px] rounded hover:bg-blue-700 text-[12px]"
                                    >
                                        Import
                                    </button>
                                    <button
                                        onClick={handleExport}
                                        className="bg-blue-600 text-white px-[1.7px] py-[1.7px] rounded hover:bg-blue-700 text-[12px]"
                                    >
                                        Export
                                    </button>
                                    <button
                                        onClick={handlePrint}
                                        className="bg-green-600 text-white px-[1.7px] py-[1.7px] rounded hover:bg-green-700 text-[12px]"
                                    >
                                        Print
                                    </button>
                                </div>
                            </div>

                            {showImportModal && (
                                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                                    <div className="bg-white p-4 rounded-lg shadow-lg max-w-md mx-auto">
                                        <h2 className="text-[10.5px] font-bold mb-2">Import Decklist</h2>
                                        <textarea
                                            value={importText}
                                            onChange={(e) => setImportText(e.target.value)}
                                            className="w-full h-32 p-2 border border-black rounded text-[12px] mb-2"
                                            placeholder="Paste PTCGL export text or leave blank to upload a file"
                                        />
                                        <div className="flex gap-2">
                                            <button
                                                onClick={handleImportFile}
                                                className="bg-blue-600 text-white px-[1.7px] py-[1.7px] rounded hover:bg-blue-700 text-[12px]"
                                            >
                                                Import File
                                            </button>
                                            <button
                                                onClick={handleImportText}
                                                className="bg-blue-600 text-white px-[1.7px] py-[1.7px] rounded hover:bg-blue-700 text-[12px]"
                                            >
                                                Import Text
                                            </button>
                                            <button
                                                onClick={() => { setShowImportModal(false); setImportText(""); }}
                                                className="bg-gray-600 text-white px-[1.7px] py-[1.7px] rounded hover:bg-gray-700 text-[12px]"
                                            >
                                                Cancel
                                            </button>
                                        </div>
                                        <input
                                            type="file"
                                            accept=".txt"
                                            ref={fileInputRef}
                                            onChange={handleFileUpload}
                                            className="hidden"
                                        />
                                    </div>
                                </div>
                            )}
                        </>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById("root"));
        root.render(<DecklistForm />);
    </script>
</body>
</html>